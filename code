--[[
    Player ESP (Filled Highlight + small name) — clean UI
    Fix: Highlight no longer disappears when players go invisible.
    Uses a client-only proxy rig when the real character is hidden.

    + Adds: "first-floor only" RemainingTime timers per plot (shows ONE per plot)
      • Tied to the same ON/OFF toggle as ESP
      • Zero behavior changes elsewhere

    PERF UPDATES (no feature changes):
      • Removed O(n^2) lookup in Heartbeat by storing Character in packet
      • Throttled proxy sync to 20 Hz instead of every Heartbeat
      • Cached core parts for invis checks (no more full GetDescendants walking each tick)
      • Proxy rigs created once per character and reused (no churn)
      • Plot refresh is per-plot with micro-debounce (no global rescans on every tiny change)
      • Distance text updates only when the displayed meters change
]]--

--// Services
local Players            = game:GetService("Players")
local UserInputService   = game:GetService("UserInputService")
local RunService         = game:GetService("RunService")
local LocalPlayer        = Players.LocalPlayer
local Camera             = workspace.CurrentCamera

--// Config
local HOTKEY_TOGGLE      = Enum.KeyCode.T

-- Name tag
local NAME_TEXT_SIZE     = 14
local NAME_FONT          = Enum.Font.GothamSemibold
local NAME_COLOR         = Color3.fromRGB(255,255,255)
local NAME_STROKE        = Color3.fromRGB(10,10,10)
local NAME_MAX_DISTANCE  = 600

-- Highlight styling (filled = "morphs" to avatar)
local HIGHLIGHT_FILL_COLOR           = Color3.fromRGB(65, 105, 225) -- RoyalBlue
local HIGHLIGHT_FILL_TRANSPARENCY    = 0.10                         -- less transparent
local HIGHLIGHT_OUTLINE_COLOR        = Color3.fromRGB(65, 105, 225) -- RoyalBlue
local HIGHLIGHT_OUTLINE_TRANSPARENCY = 0.15                         -- more visible outline

-- Panel styling
local PANEL_PRIMARY      = Color3.fromRGB(28, 28, 33)
local PANEL_ACCENT       = Color3.fromRGB(235, 64, 52)
local PANEL_TEXT         = Color3.fromRGB(235, 235, 235)

--// State
local ESPEnabled         = true
type Packet = {
    Highlight: Highlight?,
    Billboard: BillboardGui?,
    Label: TextLabel?,
    Head: BasePart?,
    HRP: BasePart?,
    Character: Model?,
    ProxyRig: Model?,
    ProxyMap: {[BasePart]: BasePart}?,
    ProxyActive: boolean?,
    CoreParts: {BasePart}?,
    LastShownMeters: number?,
}
local PerPlayer: {[Player]: Packet} = {}
local Connections: {[Player]: {RBXScriptConnection}} = {}

-- Folder to hold proxy rigs (keeps workspace tidy)
local PROXY_FOLDER = workspace:FindFirstChild("_ESP_ProxyRigs") :: Folder
if not PROXY_FOLDER then
    PROXY_FOLDER = Instance.new("Folder")
    PROXY_FOLDER.Name = "_ESP_ProxyRigs"
    PROXY_FOLDER.Parent = workspace
end

--// UI: control panel (clean + drag handle)
local controlGui = Instance.new("ScreenGui")
controlGui.Name = "ESPControlGui"
controlGui.IgnoreGuiInset = false -- don't overlap toolbar/topbar
controlGui.ResetOnSpawn = false
controlGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
controlGui.Parent = LocalPlayer:WaitForChild("PlayerGui")

local panel = Instance.new("Frame")
panel.Name = "ESPPanel"
panel.Size = UDim2.fromOffset(200, 60)
panel.Position = UDim2.fromOffset(24, 120)
panel.BackgroundColor3 = PANEL_PRIMARY
panel.BorderSizePixel = 0
panel.Parent = controlGui

local uiCorner = Instance.new("UICorner")
uiCorner.CornerRadius = UDim.new(0, 10)
uiCorner.Parent = panel

local stroke = Instance.new("UIStroke")
stroke.Thickness = 1
stroke.Color = Color3.fromRGB(60, 60, 68)
stroke.Transparency = 0.25
stroke.Parent = panel

local title = Instance.new("TextLabel")
title.BackgroundTransparency = 1
title.Size = UDim2.new(1, -12, 0, 20)
title.Position = UDim2.fromOffset(10, 6)
title.Font = Enum.Font.GothamBold
title.TextSize = 15
title.TextXAlignment = Enum.TextXAlignment.Left
title.Text = "ESP"
title.TextColor3 = PANEL_TEXT
title.Parent = panel

local hint = Instance.new("TextLabel")
hint.BackgroundTransparency = 1
hint.Size = UDim2.new(1, -12, 0, 16)
hint.Position = UDim2.fromOffset(10, 26)
hint.Font = Enum.Font.Gotham
hint.TextSize = 12
hint.TextXAlignment = Enum.TextXAlignment.Left
hint.TextTransparency = 0.2
hint.Text = "T to toggle"
hint.TextColor3 = Color3.fromRGB(200, 200, 210)
hint.Parent = panel

local toggleBtn = Instance.new("TextButton")
toggleBtn.Name = "Toggle"
toggleBtn.Size = UDim2.fromOffset(84, 28)
toggleBtn.Position = UDim2.new(1, -10 - 84, 1, -8 - 28)
toggleBtn.BackgroundColor3 = PANEL_ACCENT
toggleBtn.BorderSizePixel = 0
toggleBtn.AutoButtonColor = true
toggleBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
toggleBtn.Font = Enum.Font.GothamSemibold
toggleBtn.TextSize = 14
toggleBtn.Text = "ON"
toggleBtn.Parent = panel

local toggleCorner = Instance.new("UICorner")
toggleCorner.CornerRadius = UDim.new(0, 8)
toggleCorner.Parent = toggleBtn

-- drag handle (top strip only)
local dragHandle = Instance.new("Frame")
dragHandle.Name = "DragHandle"
dragHandle.BackgroundTransparency = 1
dragHandle.Size = UDim2.new(1, -8, 0, 34)
dragHandle.Position = UDim2.fromOffset(4, 4)
dragHandle.ZIndex = panel.ZIndex + 1
dragHandle.Parent = panel

-- Smooth, bounded dragging
do
    local dragging = false
    local dragOffset = Vector2.zero
    local function clampToViewport(px, py)
        local vp = Camera.ViewportSize
        local sz = panel.AbsoluteSize
        local x = math.clamp(px, 0, math.max(0, vp.X - sz.X))
        local y = math.clamp(py, 0, math.max(0, vp.Y - sz.Y))
        return x, y
    end

    dragHandle.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragOffset = input.Position - panel.AbsolutePosition
        end
    end)

    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            local rawX = input.Position.X - dragOffset.X
            local rawY = input.Position.Y - dragOffset.Y
            local x, y = clampToViewport(rawX, rawY)
            panel.Position = UDim2.fromOffset(x, y)
        end
    end)

    Camera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
        local pos = panel.AbsolutePosition
        local x, y = clampToViewport(pos.X, pos.Y)
        panel.Position = UDim2.fromOffset(x, y)
    end)
end

local function cleanupPlayer(player: Player)
    if Connections[player] then
        for _, c in ipairs(Connections[player]) do
            pcall(function() c:Disconnect() end)
        end
        Connections[player] = nil
    end
    local pkt = PerPlayer[player]
    if not pkt then return end
    if pkt.Highlight then pkt.Highlight:Destroy() end
    if pkt.Billboard then pkt.Billboard:Destroy() end
    if pkt.ProxyRig then pkt.ProxyRig:Destroy() end
    PerPlayer[player] = nil
end

local function makeNameBillboard(head: BasePart, player: Player)
    local bb = Instance.new("BillboardGui")
    bb.Name = "ESP_NameTag"
    bb.Size = UDim2.new(0, 140, 0, 22)
    bb.StudsOffset = Vector3.new(0, 3.0, 0)
    bb.AlwaysOnTop = true
    bb.MaxDistance = NAME_MAX_DISTANCE
    bb.Parent = head

    local label = Instance.new("TextLabel")
    label.BackgroundTransparency = 1
    label.Size = UDim2.new(1, 0, 1, 0)
    label.TextColor3 = NAME_COLOR
    label.TextStrokeColor3 = NAME_STROKE
    label.TextStrokeTransparency = 0.45
    label.Font = NAME_FONT
    label.TextScaled = false
    label.TextSize = NAME_TEXT_SIZE
    label.Text = (player.DisplayName ~= "" and player.DisplayName or player.Name)
    label.Parent = bb

    return bb, label
end

-- proxy rig builder (lazy; reused forever)
local function createProxyRigFor(character: Model): (Model, {[BasePart]: BasePart})
    local proxy = Instance.new("Model")
    proxy.Name = "_ESPProxy_" .. (character:GetDebugId():gsub("%W",""))
    proxy.Parent = PROXY_FOLDER

    local map: {[BasePart]: BasePart} = {}
    for _, desc in ipairs(character:GetDescendants()) do
        if desc:IsA("BasePart") then
            local p = Instance.new("Part")
            p.Anchored = true
            p.CanCollide = false
            p.CanTouch = false
            p.CanQuery = false
            p.CastShadow = false
            p.Size = desc.Size
            p.CFrame = desc.CFrame
            p.Transparency = 0.999
            p.Material = Enum.Material.SmoothPlastic
            p.Name = "Proxy_" .. desc.Name
            p.Parent = proxy
            map[desc] = p
        end
    end
    return proxy, map
end

-- cache core parts once; avoids tree walks every tick
local CORE_NAMES = {
    "Head","UpperTorso","LowerTorso","Torso",
    "LeftUpperArm","LeftLowerArm","LeftHand",
    "RightUpperArm","RightLowerArm","RightHand",
    "LeftUpperLeg","LeftLowerLeg","LeftFoot",
    "RightUpperLeg","RightLowerLeg","RightFoot",
    "Left Arm","Right Arm","Left Leg","Right Leg",
    "HumanoidRootPart",
}
local function collectCoreParts(character: Model): {BasePart}
    local core: {BasePart} = {}
    for _, name in ipairs(CORE_NAMES) do
        local p = character:FindFirstChild(name)
        if p and p:IsA("BasePart") then
            table.insert(core, p)
        end
    end
    -- fallback: include any BasePart directly under character (cheap)
    if #core == 0 then
        for _, d in ipairs(character:GetChildren()) do
            if d:IsA("BasePart") then table.insert(core, d) end
        end
    end
    return core
end

local function isCharacterInvisibleFast(coreParts: {BasePart}): boolean
    for _, part in ipairs(coreParts) do
        if part.Parent then
            local lt = (part.LocalTransparencyModifier or 0)
            local t  = part.Transparency
            if (lt < 0.95) and (t < 0.95) then
                return false
            end
        end
    end
    return true
end

local function setProxyActive(pkt: Packet, active: boolean)
    pkt.ProxyActive = active
    if active then
        if not pkt.ProxyRig or not pkt.ProxyRig.Parent then
            local pr, map = createProxyRigFor(pkt.Character :: Model)
            pkt.ProxyRig = pr
            pkt.ProxyMap = map
        end
    end
end

--========================================================--
-- First-floor-only RemainingTime (ONE timer per plot), per-plot refresh
--========================================================--
local PLOTS = workspace:FindFirstChild("Plots")
local FIRST_FLOOR_MAX_DISTANCE = 99999
local FIRST_FLOOR_SIZE = UDim2.new(30, 0, 30, 0)

-- per-plot state (no global rescans)
local plotState: {[Instance]: {selected: BillboardGui?}} = {}
local plotNextAllowed: {[Instance]: number} = {}
local PLOT_COOLDOWN = 0.15 -- micro debounce

local function refreshSinglePlot(plot: Instance)
    local lowestGui: BillboardGui? = nil
    local lowestY = math.huge

    for _, d in ipairs((plot :: Instance):GetDescendants()) do
        if d:IsA("TextLabel") and d.Name == "RemainingTime" then
            local gui = d.Parent
            if gui and gui:IsA("BillboardGui") then
                local y
                if gui.Adornee and gui.Adornee:IsA("BasePart") then
                    y = gui.Adornee.Position.Y
                elseif gui.Parent and gui.Parent:IsA("BasePart") then
                    y = (gui.Parent :: BasePart).Position.Y
                end
                if y and y < lowestY then
                    lowestY = y
                    lowestGui = gui
                end
            end
        end
    end

    -- apply enable to winner, disable others (but only inside this plot)
    for _, d in ipairs((plot :: Instance):GetDescendants()) do
        if d:IsA("TextLabel") and d.Name == "RemainingTime" then
            local gui = d.Parent
            if gui and gui:IsA("BillboardGui") then
                if gui == lowestGui then
                    gui.Enabled = ESPEnabled
                    gui.MaxDistance = FIRST_FLOOR_MAX_DISTANCE
                    gui.AlwaysOnTop = true
                    gui.Size = FIRST_FLOOR_SIZE
                else
                    gui.Enabled = false
                end
            end
        end
    end

    plotState[plot] = plotState[plot] or {}
    plotState[plot].selected = lowestGui
end

local function schedulePlotRefresh(plot: Instance)
    if not PLOTS then return end
    local now = os.clock()
    local nextAllowed = plotNextAllowed[plot] or 0
    if now < nextAllowed then return end
    plotNextAllowed[plot] = now + PLOT_COOLDOWN
    task.defer(function()
        if ESPEnabled and plot.Parent == PLOTS then
            refreshSinglePlot(plot)
        end
    end)
end

local function firstFloorHideAll()
    if not PLOTS then return end
    for _, plot in ipairs(PLOTS:GetChildren()) do
        local st = plotState[plot]
        if st and st.selected and st.selected.Parent then
            st.selected.Enabled = false
        end
    end
end

local function firstFloorInit()
    if not PLOTS then return end
    -- initial per-plot compute (once)
    for _, plot in ipairs(PLOTS:GetChildren()) do
        refreshSinglePlot(plot)
    end
    -- incremental updates (per-plot only)
    PLOTS.ChildAdded:Connect(function(ch) schedulePlotRefresh(ch) end)
    PLOTS.ChildRemoved:Connect(function(ch) plotState[ch] = nil end)
    PLOTS.DescendantAdded:Connect(function(inst)
        local plot = inst:FindFirstAncestorOfClass("Model") or inst:FindFirstAncestorWhichIsA("Folder")
        if plot and plot.Parent == PLOTS then schedulePlotRefresh(plot) end
    end)
    PLOTS.DescendantRemoving:Connect(function(inst)
        local plot = inst:FindFirstAncestorOfClass("Model") or inst:FindFirstAncestorWhichIsA("Folder")
        if plot and plot.Parent == PLOTS then schedulePlotRefresh(plot) end
    end)
end

if PLOTS then
    firstFloorInit()
end
--========================================================--

-- Toggle all per-player visuals (no proxy destroy; reuse)
local function enableESPForPlayer(player: Player, enable: boolean)
    local pkt = PerPlayer[player]
    if not pkt then return end

    if pkt.Highlight then
        pkt.Highlight.Enabled = enable
    end

    if pkt.Billboard then
        local ok = pcall(function()
            (pkt.Billboard :: any).Enabled = enable
        end)
        if not ok then
            if enable and pkt.Head and pkt.Billboard.Parent ~= pkt.Head then
                pkt.Billboard.Parent = pkt.Head
            elseif not enable then
                pkt.Billboard.Parent = nil
            end
        end
    end

    if not enable then
        setProxyActive(pkt, false) -- keep built, just inactive
    end
end

local function setESPEnabled(on: boolean)
    ESPEnabled = on
    if on then
        toggleBtn.Text = "ON"; toggleBtn.BackgroundColor3 = PANEL_ACCENT
    else
        toggleBtn.Text = "OFF"; toggleBtn.BackgroundColor3 = Color3.fromRGB(70, 70, 78)
    end
    for plr, _ in pairs(PerPlayer) do
        enableESPForPlayer(plr, on)
    end
    if PLOTS then
        if on then
            for _, plot in ipairs(PLOTS:GetChildren()) do schedulePlotRefresh(plot) end
        else
            firstFloorHideAll()
        end
    end
end

toggleBtn.MouseButton1Click:Connect(function()
    setESPEnabled(not ESPEnabled)
end)

UserInputService.InputBegan:Connect(function(input, gp)
    if gp then return end
    if input.KeyCode == HOTKEY_TOGGLE then
        setESPEnabled(not ESPEnabled)
    end
end)

-- Attach ESP for a character
local function attachForCharacter(player: Player, character: Model)
    if player == LocalPlayer then return end

    local head: BasePart? = character:FindFirstChild("Head") :: BasePart?
    local hrp: BasePart?  = character:FindFirstChild("HumanoidRootPart") :: BasePart?
    if not head or not hrp then
        head = character:WaitForChild("Head", 5)
        hrp  = character:WaitForChild("HumanoidRootPart", 5)
        if not head or not hrp then return end
    end

    local hl = Instance.new("Highlight")
    hl.Name = "ESP_Highlight"
    hl.Adornee = character
    hl.FillColor = HIGHLIGHT_FILL_COLOR
    hl.FillTransparency = HIGHLIGHT_FILL_TRANSPARENCY
    hl.OutlineColor = HIGHLIGHT_OUTLINE_COLOR
    hl.OutlineTransparency = HIGHLIGHT_OUTLINE_TRANSPARENCY
    hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    hl.Enabled = ESPEnabled
    hl.Parent = character

    local bb, label = makeNameBillboard(head, player)
    if not ESPEnabled then bb.Parent = nil end

    PerPlayer[player] = {
        Highlight = hl,
        Billboard = bb,
        Label = label,
        Head = head,
        HRP = hrp,
        Character = character,
        ProxyRig = nil,
        ProxyMap = nil,
        ProxyActive = false,
        CoreParts = collectCoreParts(character),
        LastShownMeters = nil,
    }
end

-- Player event wiring
local function onPlayerAdded(player: Player)
    local nameConn = player:GetPropertyChangedSignal("DisplayName"):Connect(function()
        local pkt = PerPlayer[player]
        if pkt and pkt.Label then
            local base = (player.DisplayName ~= "" and player.DisplayName or player.Name)
            pkt.Label.Text = pkt.LastShownMeters and (base .. "  [" .. pkt.LastShownMeters .. "m]") or base
        end
    end)

    local charConn = player.CharacterAdded:Connect(function(char)
        -- clean previous packet if any (prevents doubles)
        cleanupPlayer(player)
        task.defer(function()
            attachForCharacter(player, char)
            enableESPForPlayer(player, ESPEnabled)
        end)
    end)

    Connections[player] = Connections[player] or {}
    table.insert(Connections[player], nameConn)
    table.insert(Connections[player], charConn)

    if player.Character then
        attachForCharacter(player, player.Character)
        enableESPForPlayer(player, ESPEnabled)
    end
end

local function onPlayerRemoving(player: Player)
    cleanupPlayer(player)
end

-- Init
for _, plr in ipairs(Players:GetPlayers()) do
    if plr ~= LocalPlayer then
        onPlayerAdded(plr)
    end
end
Players.PlayerAdded:Connect(onPlayerAdded)
Players.PlayerRemoving:Connect(onPlayerRemoving)

-- Distance + invisibility updater (shared cadence; light work)
task.spawn(function()
    while true do
        task.wait(0.35)
        if not ESPEnabled then continue end

        local lpChar = LocalPlayer.Character
        local lpRoot = lpChar and lpChar:FindFirstChild("HumanoidRootPart")

        for plr, pkt in pairs(PerPlayer) do
            -- distance label (only when value changes)
            if lpRoot and pkt and pkt.Label and pkt.HRP then
                local meters = math.floor((lpRoot.Position - pkt.HRP.Position).Magnitude + 0.5)
                if pkt.LastShownMeters ~= meters then
                    pkt.LastShownMeters = meters
                    local base = (plr.DisplayName ~= "" and plr.DisplayName or plr.Name)
                    pkt.Label.Text = string.format("%s  [%dm]", base, meters)
                end
            end

            -- invisibility handling with cached core parts
            local char = pkt.Character
            if char and pkt.Highlight and pkt.CoreParts then
                local invisible = isCharacterInvisibleFast(pkt.CoreParts)
                if invisible then
                    if not pkt.ProxyActive then
                        setProxyActive(pkt, true)
                    end
                    if pkt.ProxyRig and pkt.Highlight.Adornee ~= pkt.ProxyRig then
                        pkt.Highlight.Adornee = pkt.ProxyRig
                    end
                else
                    if pkt.Highlight.Adornee ~= char then
                        pkt.Highlight.Adornee = char
                    end
                    -- keep proxy built, just inactive
                    if pkt.ProxyActive then
                        setProxyActive(pkt, false)
                    end
                end
            end
        end
    end
end)

-- PERF: throttle proxy sync to 20 Hz & only when proxy is active
local PROXY_UPDATE_INTERVAL = 1/20
local accum = 0
RunService.Heartbeat:Connect(function(dt)
    accum += dt
    if accum < PROXY_UPDATE_INTERVAL then return end
    accum -= PROXY_UPDATE_INTERVAL

    for _, pkt in pairs(PerPlayer) do
        if pkt and pkt.ProxyActive and pkt.ProxyRig and pkt.ProxyMap and pkt.Character then
            -- only sync while in use (active)
            for src, proxyPart in pairs(pkt.ProxyMap) do
                if src.Parent and proxyPart.Parent then
                    local ok1 = pcall(function() proxyPart.CFrame = src.CFrame end)
                    if ok1 and proxyPart.Size ~= src.Size then
                        pcall(function() proxyPart.Size = src.Size end)
                    end
                end
            end
        end
    end
end)

-- External toggle if your executor UI wants to call it
toggleBtn.Text = "ON"; toggleBtn.BackgroundColor3 = PANEL_ACCENT
_G.SetESPEnabled = function(on)
    setESPEnabled(on and true or false)
end

